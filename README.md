# 项目综合说明文档

## 目录

1. [项目概述](#项目概述)
2. [用户使用说明](#用户使用说明)
3. [项目结构说明](#项目结构说明)
4. [计算逻辑说明](#计算逻辑说明)

---

## 项目概述

本项目(瓦斯数据与赋存规律分析系统）是一个基于 Web 的地理空间数据计算与可视化系统，主要用于渔网点数据的多指标综合评价计算和空间插值分析。系统采用前后端分离架构，前端使用 Leaflet.js 进行地图可视化，后端使用 Node.js + Express 提供 API 服务，Python 脚本执行复杂的数值计算。

### 核心功能

- **多指标综合评价计算**：支持熵权法、G1法、组合权重法、加权求和法等多种权重计算方法
- **交互式地图可视化**：支持热力图、点符号图、阈值分类图等多种可视化方式
- **数据管理**：支持数据库表管理、图层管理、计算结果历史记录等

---

## 用户使用说明

### 1. 系统界面介绍

系统界面分为三个主要部分：

#### 1.1 顶部导航栏
- **图层信息**按钮：切换到图层信息面板，显示 QGIS 导出的静态图层
- **计算编辑**按钮：切换到计算编辑面板，显示数据库连接的计算图层和计算结果

#### 1.2 左侧面板（配置面板）
根据当前模式显示不同的内容：

**图层信息模式**：
- 显示 QGIS 导出的静态图层列表
- 可以控制图层的显示/隐藏

**计算编辑模式**：
- **步骤1：选择数据表**：从数据库中选择要计算的数据表
- **步骤2：选择字段**：选择参与计算的数值字段（f1, f2, f3, f4 等）
- **步骤3：配置计算参数**：根据选择的计算方法配置相应参数
- **执行计算**：点击"计算"按钮执行计算任务

#### 1.3 右侧面板（结果面板）
根据当前模式显示不同的内容：

**图层信息模式**：
- 显示 QGIS 图层的详细信息

**计算编辑模式**：
- **计算结果列表**：显示所有历史计算任务
- **图层控制**：每个计算结果可以：
  - 勾选/取消勾选显示在地图上
  - 调整透明度（0-100%）
  - 展开/折叠可视化选项
  - 查看数据详情
  - 删除计算结果

### 2. 计算功能使用

#### 2.1 熵权法计算

**适用场景**：当需要根据数据本身的变异程度自动确定权重时使用。

**操作步骤**：
1. 在左侧面板选择数据表和字段
2. 选择计算方法为"熵权法"
3. 配置参数：
   - **标准化方法**：选择 min-max（最小-最大标准化）或 z-score（Z分数标准化）
   - **指标影响方向**：设置每个指标是正向影响（1）还是负向影响（-1）
4. 点击"计算"按钮

**效果说明**：
- 系统会自动计算每个指标的信息熵
- 根据信息熵计算权重（熵值越小，权重越大）
- 计算每个点的综合得分并显示在地图上

#### 2.2 G1法计算

**适用场景**：当有专家确定的指标重要性排序时使用。

**操作步骤**：
1. 选择数据表和字段
2. 选择计算方法为"G1法"
3. 配置参数：
   - **r值列表**：相邻指标的重要度比值（通常范围 1.0-1.8）
   - 例如：如果有4个指标，需要3个r值，表示第1个指标与第2个指标的重要度比、第2个与第3个的比、第3个与第4个的比
4. 点击"计算"按钮

**效果说明**：
- 根据专家确定的指标排序和重要度比值计算权重
- 权重反映专家对指标重要性的判断

#### 2.3 组合权重法计算

**适用场景**：结合主观权重（G1法）和客观权重（熵权法）的优势。

**操作步骤**：
1. 选择数据表和字段
2. 选择计算方法为"组合权重法（罗金辉）"或"组合权重法（博弈论）"
3. 配置参数：
   - **G1 r值**：G1法的重要度比值
   - **标准化方法**：数据标准化方法
   - **指标影响方向**：每个指标的影响方向
4. 点击"计算"按钮

**效果说明**：
- 罗金辉方法：根据G1权重的差异系数自动确定组合系数
- 博弈论方法：通过求解优化问题确定最优组合系数
- 最终权重综合了主观和客观信息

#### 2.4 加权求和法计算

**适用场景**：当需要手动指定各指标的权重时使用。

**操作步骤**：
1. 选择数据表和字段
2. 选择计算方法为"加权求和法"
3. 配置参数：
   - **权重设置**：为每个字段手动设置权重值（权重会自动归一化）
   - **标准化方法**：数据标准化方法
   - **指标影响方向**：每个指标的影响方向
4. 点击"计算"按钮

**效果说明**：
- 使用用户指定的权重进行加权求和
- 适合有明确权重分配方案的情况

### 3. 可视化功能使用

#### 3.1 渲染方式选择

每个计算结果支持三种渲染方式：

**点符号图**：
- 每个数据点显示为一个圆形符号
- 颜色根据数值大小映射
- 可调整点的大小（半径）

**热力图**：
- 使用 Leaflet.heat 插件渲染
- 根据数据点密度和数值强度生成热力图
- 可调整半径（影响范围）和模糊度（平滑程度）

**阈值分类**：
- 将数值分为若干等级
- 每个等级用不同颜色表示
- 可调整分级数量（3-10级）

#### 3.2 颜色方案选择

系统提供多种颜色方案：
- **红-黄-绿**：从红色（低值）到绿色（高值）
- **蓝-红**：从蓝色（低值）到红色（高值）
- **Viridis**：科学可视化常用色带
- **Plasma**：另一种科学可视化色带
- **冷-暖**：从冷色调到暖色调

#### 3.3 值域设置

- **自动值域**：点击"自动"按钮，使用数据的最小值和最大值
- **手动值域**：手动输入最小值和最大值，用于固定颜色映射范围

#### 3.4 应用设置

修改可视化参数后，点击"应用设置"按钮：
- 系统会重新创建图层以应用新设置
- 按钮会短暂显示"已应用"提示

#### 3.5 透明度调整

- 使用透明度滑块实时调整图层透明度（0-100%）
- 调整会立即生效，无需点击应用按钮

### 4. 插值功能使用

#### 4.1 创建插值栅格

1. 在计算编辑面板选择"插值"功能
2. 选择数据表和字段
3. 配置插值参数：
   - **插值方法**：IDW、最近邻、线性插值
   - **搜索半径**：IDW方法的搜索范围（可选）
   - **幂次**：IDW方法的距离衰减指数（默认2）
   - **像元大小**：输出栅格的像元大小
   - **色带**：选择颜色方案
4. 点击"生成"按钮

#### 4.2 查看插值结果

- 生成的栅格会自动添加到地图上
- 可以在右侧面板控制栅格的显示/隐藏和透明度

### 5. 数据查看功能

点击计算结果右侧的"查看"按钮：
- 显示该计算任务的所有数据点
- 包括点ID、点顺序、计算值等信息
- 支持按值排序和搜索

---

## 项目结构说明

### 1. 整体架构

```
wasi_4/
├── client/                    # 前端客户端代码
│   ├── edit_calculate.js     # 计算编辑面板主逻辑
│   └── edit_calculate.css    # 样式文件
├── server/                    # 后端服务器代码
│   ├── index.js              # Express 服务器入口
│   ├── routes/               # API 路由
│   │   ├── yw.js             # 渔网计算相关 API
│   │   ├── interpolate.js    # 插值相关 API
│   │   ├── editcalc.js       # 数据编辑相关 API
│   │   ├── layers.js         # 图层管理 API
│   │   └── rasters.js        # 栅格管理 API
│   ├── services/             # 服务层
│   │   ├── pythonRunner.js   # Python 脚本执行服务
│   │   └── rasterService.js  # 栅格处理服务
│   ├── utils/                # 工具函数
│   │   ├── db_yw.js          # 渔网数据库工具
│   │   └── db.js             # 通用数据库工具
│   ├── scripts/              # Python 脚本
│   │   ├── interpolate.py    # 插值脚本（完整版）
│   │   ├── interpolate_v2.py # 插值脚本（简化版）
│   │   └── interpolate_simple.py # 插值脚本（最小依赖版）
│   ├── compute_yw.py         # 渔网计算主脚本
│   └── requirements.txt      # Python 依赖
├── sample/                    # 示例数据和计算模块
│   ├── Entropy.py            # 熵权法计算模块
│   ├── G1.py                 # G1法计算模块
│   ├── CombineWeight.py      # 组合权重计算模块
│   └── 83yuwang/             # 示例 Shapefile 数据
├── db/                        # 数据库文件
│   ├── 83yuwang.sqlite       # 主数据库（SpatiaLite）
│   └── ...
├── qgis2web_2025_09_19-16_43_01_978602/  # QGIS 导出静态文件
│   ├── index.html            # 主 HTML 文件
│   ├── js/                   # JavaScript 库
│   ├── css/                  # 样式文件
│   └── data/                 # 静态数据文件
└── package.json              # Node.js 依赖配置
```

### 2. 前端架构

#### 2.1 技术栈
- **Leaflet.js**：地图可视化库
- **Leaflet.heat**：热力图插件
- **原生 JavaScript**：无框架，直接操作 DOM

#### 2.2 核心文件说明

**`client/edit_calculate.js`**：
- 计算编辑面板的核心逻辑
- 管理图层状态、计算结果、可视化配置
- 处理用户交互（计算、可视化、数据查看）
- 约 2100 行代码，包含：
  - 状态管理（Map 数据结构存储图层、配置等）
  - API 调用（与后端通信）
  - 图层创建和管理（点符号、热力图、阈值分类）
  - 可视化选项渲染和事件绑定

**`qgis2web_2025_09_19-16_43_01_978602/index.html`**：
- 主 HTML 文件
- 加载 Leaflet 和相关插件
- 定义页面布局（顶部导航、左右面板、地图容器）
- 初始化地图和图层

#### 2.3 前端数据流

```
用户操作
  ↓
edit_calculate.js 处理事件
  ↓
调用 API（fetch）
  ↓
后端处理并返回数据
  ↓
更新前端状态
  ↓
重新渲染 UI 和地图图层
```

### 3. 后端架构

#### 3.1 技术栈
- **Node.js + Express**：Web 服务器框架
- **SQLite3 + SpatiaLite**：空间数据库
- **Python**：数值计算脚本

#### 3.2 核心文件说明

**`server/index.js`**：
- Express 应用入口
- 配置中间件（body-parser、CSP）
- 注册路由模块
- 静态文件服务

**`server/routes/yw.js`**：
- 渔网计算相关 API 路由
- 主要接口：
  - `POST /api/yw/compute`：执行计算任务
  - `GET /api/yw/runs`：获取所有计算任务
  - `GET /api/yw/run/:id`：获取单个任务详情
  - `GET /api/yw/run/:id/geojson`：获取任务结果的 GeoJSON（带坐标转换）
  - `GET /api/yw/run/:id/values`：获取任务结果的数据值
  - `PATCH /api/yw/run/:id/name`：更新任务名称
  - `DELETE /api/yw/run/:id`：删除任务
- 坐标转换功能：将 EPSG:2415（北京1954坐标系）转换为 EPSG:4326（WGS84）

**`server/routes/interpolate.js`**：
- 插值相关 API
- `POST /api/interpolate`：执行插值计算

**`server/services/pythonRunner.js`**：
- Python 脚本执行服务
- `runPython(script, args)`：执行 Python 脚本
- `runPythonWithStdin(script, args, stdinData)`：通过 stdin 传递数据（避免命令行编码问题）

**`server/utils/db_yw.js`**：
- 渔网数据库工具
- `openDb()`：打开数据库连接并加载 SpatiaLite 扩展

#### 3.3 后端数据流

```
HTTP 请求
  ↓
Express 路由
  ↓
数据库操作 / Python 脚本调用
  ↓
返回 JSON 响应
```

### 4. 数据库结构

#### 4.1 主数据库（83yuwang.sqlite）

**表1：yw_point**
- 存储原始渔网点数据
- 字段：
  - `ogc_fid`：主键
  - `f1, f2, f3, f4`：四个数值字段（构造坡、底板标高、砂体、钻孔瓦斯含量）
  - `GEOMETRY`：点的几何信息（POINT，SRID=2415）

**表2：yw_run**
- 存储计算任务记录
- 字段：
  - `run_id`：主键（自增）
  - `name`：任务名称
  - `method`：计算方法（entropy, g1, combined_luo, combined_gt, weighted_sum）
  - `created_at`：创建时间
  - `params_json`：参数配置（JSON 字符串）

**表3：yw_value**
- 存储计算结果
- 字段：
  - `run_id`：任务ID（外键）
  - `point_id`：点ID（外键）
  - `value`：计算结果值
  - 主键：`(run_id, point_id)`

#### 4.2 空间数据库特性

- 使用 SpatiaLite 扩展支持空间数据类型和函数
- 支持 `ST_X`, `ST_Y`, `AsGeoJSON`, `Transform` 等空间函数
- 自动维护空间索引（R-Tree）

### 5. Python 计算模块

#### 5.1 计算脚本

**`server/compute_yw.py`**：
- 主计算脚本，从数据库读取数据，执行计算，写入结果
- 支持多种计算方法（通过命令行参数或 stdin 接收 JSON 配置）
- 输出 JSON 格式的结果

**`sample/Entropy.py`**：
- 熵权法计算模块
- `standardize_data()`：数据标准化
- `calculate_entropy()`：计算信息熵和权重

**`sample/G1.py`**：
- G1法计算模块
- `calculate_g1_weights()`：根据指标排序和重要度比值计算权重

**`sample/CombineWeight.py`**：
- 组合权重计算模块
- `Luo_combined_weights()`：罗金辉组合权重方法
- `GT_combined_weights()`：博弈论组合权重方法
- `solve_optimal_lambda()`：求解最优组合系数

#### 5.2 插值脚本

**`server/scripts/interpolate_v2.py`**：
- 主要使用的插值脚本
- 支持 IDW、最近邻、线性插值
- 通过 stdin 接收字段配置（避免命令行编码问题）
- 输出 PNG 栅格和 world 文件

---

## 计算逻辑说明

### 1. 数据标准化

#### 1.1 Min-Max 标准化

**公式**：
- 正向指标：`std_value = (value - min) / (max - min)`
- 负向指标：`std_value = (max - value) / (max - min)`

**原理**：
- 将数据映射到 [0, 1] 区间
- 正向指标：值越大，标准化值越大
- 负向指标：值越大，标准化值越小（通过取反实现）

**代码位置**：`sample/Entropy.py` 的 `standardize_data()` 函数

#### 1.2 Z-Score 标准化

**公式**：`std_value = (value - mean) / std`

**原理**：
- 将数据转换为均值为 0、标准差为 1 的分布
- 适合数据分布接近正态分布的情况

**代码位置**：`sample/Entropy.py` 的 `standardize_data()` 函数

### 2. 熵权法计算

#### 2.1 计算原理

熵权法是一种客观赋权方法，基于信息熵理论。信息熵越大，指标提供的信息量越少，权重越小；反之，信息熵越小，指标提供的信息量越多，权重越大。

#### 2.2 计算步骤

**步骤1：计算比重矩阵**

对于标准化后的数据矩阵，计算每个值在所在列中的比重：

```
p_ij = x_ij / Σ(x_ij)  (i=1,2,...,n; j=1,2,...,m)
```

其中：
- `x_ij`：第 i 个对象在第 j 个指标上的标准化值
- `n`：对象数量
- `m`：指标数量

**步骤2：计算信息熵**

```
E_j = -k * Σ(p_ij * ln(p_ij))  (i=1,2,...,n)
```

其中：
- `k = 1 / ln(n)`：常数，确保熵值在 [0, 1] 区间
- 当 `p_ij = 0` 时，`p_ij * ln(p_ij) = 0`（避免 log(0)）

**步骤3：计算权重**

```
w_j = (1 - E_j) / Σ(1 - E_k)  (k=1,2,...,m)
```

权重归一化，确保 `Σw_j = 1`。

#### 2.3 代码实现

**文件**：`sample/Entropy.py`

**关键函数**：
- `calculate_entropy(standardized_data, indicator_names)`：
  1. 计算比重矩阵 `p_matrix`
  2. 计算每个指标的信息熵 `entropy`
  3. 计算权重 `weights = (1 - entropy) / sum(1 - entropy)`
  4. 返回权重字典

**调用流程**：
```
compute_yw.py::compute_entropy()
  ↓
ew.standardize_data()  # 标准化
  ↓
ew.calculate_entropy()  # 计算权重
  ↓
加权求和计算综合得分
```

### 3. G1法计算

#### 3.1 计算原理

G1法是一种主观赋权方法，基于专家确定的指标重要性排序和相邻指标的重要度比值。

#### 3.2 计算步骤

**步骤1：确定指标排序**

专家确定指标的排序关系，例如：
```
U1 > U2 > U3 > ... > Um
```
其中 `>` 表示"重要于"。

**步骤2：确定重要度比值**

专家确定相邻指标的重要度比值：
```
r1 = ω1* / ω2*  (第1个指标与第2个指标的重要度比)
r2 = ω2* / ω3*  (第2个指标与第3个指标的重要度比)
...
r(m-1) = ω(m-1)* / ωm*  (第m-1个指标与第m个指标的重要度比)
```

通常 `r` 的取值范围为 [1.0, 1.8]：
- `r = 1.0`：两个指标同等重要
- `r = 1.2`：前一个指标比后一个指标稍重要
- `r = 1.8`：前一个指标比后一个指标明显重要

**步骤3：计算最次要指标的权重**

```
ωm* = 1 / [1 + Σ(i=1到m-1) Π(g=i到m-1) r_g]
```

其中：
- `Π(g=i到m-1) r_g`：从 `r_i` 到 `r(m-1)` 的连乘积
- `Σ(i=1到m-1)`：对所有 i 求和

**步骤4：反向计算其他指标权重**

```
ω(m-1)* = r(m-1) * ωm*
ω(m-2)* = r(m-2) * ω(m-1)*
...
ω1* = r1 * ω2*
```

**步骤5：归一化**

```
ωi = ωi* / Σ(ωj*)  (j=1,2,...,m)
```

#### 3.3 代码实现

**文件**：`sample/G1.py`

**关键函数**：
- `calculate_g1_weights(indicators, r_values)`：
  1. 验证输入（r_values 长度应为 m-1）
  2. 计算最次要指标权重 `omega_m_star`
  3. 反向计算其他指标权重
  4. 归一化并返回权重字典

**调用流程**：
```
compute_yw.py::compute_g1()
  ↓
g1w.calculate_g1_weights()  # 计算 G1 权重
  ↓
ew.standardize_data()  # 标准化数据
  ↓
加权求和计算综合得分
```

### 4. 组合权重法计算

#### 4.1 罗老师组合权重法

**原理**：
组合权重公式：
```
w = t * w_G1 + (1-t) * w_I
```

其中：
- `w_G1`：G1法权重（主观权重）
- `w_I`：熵权法权重（客观权重）
- `t`：组合系数，由 G1 权重的差异系数确定

**差异系数计算**：
```
G_G1 = std(w_G1) / mean(w_G1)
```

**组合系数计算**：
```
t = (2 / (m-1)) * G_G1
```

如果 `m=1`（单指标），则 `t=0.5`。

**约束**：`t` 限制在 [0, 1] 范围内。

**代码实现**：
- 文件：`sample/CombineWeight.py`
- 函数：`Luo_combined_weights(w_G1_weight_map, w_I_weight_map)`

#### 4.2 博弈论组合权重法

**原理**：
通过求解优化问题确定最优组合系数，使组合权重同时接近两种权重。

**目标函数**：
```
min ||λ1*w1 + λ2*w2 - w1||² + ||λ1*w1 + λ2*w2 - w2||²
```

约束条件：
```
λ1 + λ2 = 1
```

**求解方法**：
1. 对目标函数求偏导并令其为 0，得到线性方程组
2. 求解线性方程组得到 `λ1` 和 `λ2`
3. 归一化：`λ1* = |λ1| / (|λ1| + |λ2|)`, `λ2* = |λ2| / (|λ1| + |λ2|)`

**组合权重**：
```
w = λ1* * w1 + λ2* * w2
```

**代码实现**：
- 文件：`sample/CombineWeight.py`
- 函数：
  - `GT_combined_weights(w_1, w_2)`：主函数
  - `solve_optimal_lambda(normalized_1, normalized_2)`：求解最优系数

### 5. 加权求和法计算

**原理**：
用户手动指定各指标的权重，直接进行加权求和。

**公式**：
```
score_i = Σ(w_j * x_ij)  (j=1,2,...,m)
```

其中：
- `w_j`：第 j 个指标的权重（用户指定，自动归一化）
- `x_ij`：第 i 个对象在第 j 个指标上的标准化值

**代码实现**：
- 文件：`server/compute_yw.py`
- 函数：`compute_weighted_sum()`

### 6. 综合得分计算

所有计算方法最终都通过加权求和计算综合得分：

```
score_i = Σ(w_j * std_ij)  (j=1,2,...,m)
```

其中：
- `w_j`：第 j 个指标的权重（由不同方法计算得到）
- `std_ij`：第 i 个对象在第 j 个指标上的标准化值

**代码位置**：`server/compute_yw.py` 的各个 `compute_*()` 函数

---

## 附录

### A. 技术栈总结

**前端**：
- Leaflet.js 1.x
- Leaflet.heat
- 原生 JavaScript（ES6+）

**后端**：
- Node.js
- Express 5.x
- SQLite3 + SpatiaLite

**计算**：
- Python 3.x
- NumPy
- Pandas
